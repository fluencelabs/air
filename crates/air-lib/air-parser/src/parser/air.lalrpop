use crate::ast::*;
use crate::parser::ParserError;
use crate::parser::VariableValidator;
use crate::parser::Span;
use crate::parser::lexer::Token;

use air_lambda_parser::LambdaAST;
use lalrpop_util::ErrorRecovery;
use std::rc::Rc;

// the only thing why input matters here is just introducing lifetime for Token
grammar<'err, 'input, 'v>(input: &'input str, errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, ParserError>>, validator: &'v mut VariableValidator<'input>);

pub AIR = Instr;

Instr: Box<Instruction<'input>> = {
    <left: @L> "(" call <triplet:Triplet> <args:Args> <output:CallOutput?> ")" <right: @R> => {
        let args = Rc::new(args);
        let output = output.map(CallOutputValue::Variable).unwrap_or(CallOutputValue::None);
        let call = Call::new(triplet, args, output);
        let span = Span::new(left, right);

        validator.met_call(&call, span);

        Box::new(Instruction::Call(call))
    },

    <left: @L> "(" ap <arg:ApArgument> <result:ApResult> ")" <right: @R> => {
        let apply = Ap::new(arg, result);

        let span = Span::new(left, right);
        validator.met_ap(&apply, span);

        Box::new(Instruction::Ap(apply))
    },

    "(" seq <l:Instr> <r:Instr> ")" => Box::new(Instruction::Seq(Seq::new(l, r))),
    "(" par <l:Instr> <r:Instr> ")" => Box::new(Instruction::Par(Par::new(l, r))),
    "(" null ")" => Box::new(Instruction::Null(Null)),

    <left: @L> "(" new <variable: ScriptVariable> <instruction:Instr> ")" <right: @R> => {
        let span = Span::new(left, right);
        let new = New::new(variable, instruction, span);

        validator.met_new(&new, span);

        Box::new(Instruction::New(new))
    },

    "(" fail <fail_body: FailBody> ")" => {
        Box::new(Instruction::Fail(fail_body))
    },

    <left: @L> "(" fold <iterable:FoldScalarIterable> <iterator:Scalar> <i:Instr> ")" <right: @R> => {
        let iterator = Scalar::new(iterator.0, iterator.1);
        let span = Span::new(left, right);
        let fold = FoldScalar::new(iterable, iterator, *i, span);

        validator.met_fold_scalar(&fold, span);

        Box::new(Instruction::FoldScalar(fold))
    },

    <left: @L> "(" fold <stream:Stream> <iterator:Scalar> <i:Instr> ")" <right: @R> => {
        let iterable = Stream::new(stream.0, stream.1);
        let iterator = Scalar::new(iterator.0, iterator.1);
        let span = Span::new(left, right);
        let fold = FoldStream::new(iterable, iterator, *i, span);

        validator.meet_fold_stream(&fold, span);

        Box::new(Instruction::FoldStream(fold))
    },

    <left: @L> "(" next <iterator:Scalar> ")" <right: @R> => {
        let iterator = Scalar::new(iterator.0, iterator.1);
        let next = Next::new(iterator);
        let span = Span::new(left, right);
        validator.met_next(&next, span);

        Box::new(Instruction::Next(next))
    },

    "(" xor <l:Instr> <r:Instr> ")" => Box::new(Instruction::Xor(Xor(l, r))),

    <left: @L> "(" match_ <l:Value> <r:Value> <i:Instr> ")" <right: @R> => {
        let match_ = Match::new(l, r, i);
        let span = Span::new(left, right);
        validator.met_match(&match_, span);

        Box::new(Instruction::Match(match_))
    },

    <left: @L> "(" mismatch <l:Value> <r:Value> <i:Instr> ")" <right: @R> => {
        let mismatch = MisMatch::new(l, r, i);
        let span = Span::new(left, right);
        validator.met_mismatch(&mismatch, span);

        Box::new(Instruction::MisMatch(mismatch))
     },

    ! => { errors.push(<>); Box::new(Instruction::Error) },
}

Args: Vec<Value<'input>> = {
    "[" <args:(<Arg>)*> "]" => args
}

Triplet: Triplet<'input> = {
    <peer_pk:PeerId> "(" <service_id:ServiceId> <function_name:Function> ")" => Triplet {
        peer_pk,
        service_id,
        function_name
    }
}

ApResult = ScriptVariable;
CallOutput = ScriptVariable;

ScriptVariable: Variable<'input> = {
    <scalar:Scalar> => Variable::scalar(scalar.0, scalar.1),
    <stream:Stream> => Variable::stream(stream.0, stream.1),
};

FailBody: Fail<'input> = {
    <scalar:Scalar> => Fail::Scalar(ScalarWithLambda::new(scalar.0, None, scalar.1)),
    <scalar:ScalarWithLambda> => Fail::Scalar(ScalarWithLambda::new(scalar.0, Some(scalar.1), scalar.2)),
    <ret_code:I64> <error_message:Literal> => Fail::Literal {
        ret_code,
        error_message,
    },
    <left: @L> <l:LastError> <right: @R> => {
        Fail::LastError
    }
}

FoldScalarIterable: FoldScalarIterable<'input> = {
    <scalar:Scalar> => FoldScalarIterable::Scalar(ScalarWithLambda::new(scalar.0, None, scalar.1)),
    <scalar:ScalarWithLambda> => FoldScalarIterable::Scalar(ScalarWithLambda::new(scalar.0, Some(scalar.1), scalar.2)),
    "[" "]" => FoldScalarIterable::EmptyArray,
};

Function = CallInstrValue;
PeerId = CallInstrValue;
ServiceId = CallInstrValue;

CallInstrValue: CallInstrValue<'input> = {
    InitPeerId => CallInstrValue::InitPeerId,
    <l:Literal> => CallInstrValue::Literal(l),
    <scalar:Scalar> => CallInstrValue::Variable(VariableWithLambda::scalar(scalar.0, scalar.1)),
    <scalar:ScalarWithLambda> => CallInstrValue::Variable(VariableWithLambda::scalar_wl(scalar.0, scalar.1, scalar.2)),
    <stream:Stream> => CallInstrValue::Variable(VariableWithLambda::stream(stream.0, stream.1)),
    <stream:StreamWithLambda> => CallInstrValue::Variable(VariableWithLambda::stream_wl(stream.0, stream.1, stream.2)),
}

Number: Number = {
    <integer:I64> => Number::Int(integer),
    <float:F64> => Number::Float(float),
}

Arg = Value;

Value: Value<'input> = {
    InitPeerId => Value::InitPeerId,
    <LastError> => Value::LastError(None),
    <le:LastErrorWithLambda> => Value::LastError(Some(le)),
    <l:Literal> => Value::Literal(l),
    Timestamp => Value::Timestamp,
    TTL => Value::TTL,
    <n:Number> => Value::Number(n),
    <b:Boolean> => Value::Boolean(b),
    "[" "]" => Value::EmptyArray,
    <scalar:Scalar> => Value::Variable(VariableWithLambda::scalar(scalar.0, scalar.1)),
    <scalar:ScalarWithLambda> => Value::Variable(VariableWithLambda::scalar_wl(scalar.0, scalar.1, scalar.2)),
    <stream:Stream> => Value::Variable(VariableWithLambda::stream(stream.0, stream.1)),
    <stream:StreamWithLambda> => Value::Variable(VariableWithLambda::stream_wl(stream.0, stream.1, stream.2)),
}

ApArgument: ApArgument<'input> = {
    InitPeerId => ApArgument::InitPeerId,
    <LastError> => ApArgument::LastError(None),
    <le:LastErrorWithLambda> => ApArgument::LastError(Some(le)),
    Timestamp => ApArgument::Timestamp,
    TTL => ApArgument::TTL,
    <l:Literal> => ApArgument::Literal(l),
    <n:Number> => ApArgument::Number(n),
    <b:Boolean> => ApArgument::Boolean(b),
    "[" "]" => ApArgument::EmptyArray,
    <scalar:Scalar> => ApArgument::Scalar(ScalarWithLambda::new(scalar.0, None, scalar.1)),
    <scalar:ScalarWithLambda> => ApArgument::Scalar(ScalarWithLambda::new(scalar.0, Some(scalar.1), scalar.2)),
}

extern {
    type Location = usize;
    type Error = ParserError;

    enum Token<'input> {
        "(" => Token::OpenRoundBracket,
        ")" => Token::CloseRoundBracket,
        "[" => Token::OpenSquareBracket,
        "]" => Token::CloseSquareBracket,

        Scalar => Token::Scalar { name:<&'input str>, position: <usize> },
        ScalarWithLambda => Token::ScalarWithLambda { name: <&'input str>, lambda: <LambdaAST<'input>>, position: <usize> },
        Stream => Token::Stream { name: <&'input str>, position: <usize> },
        StreamWithLambda => Token::StreamWithLambda {name: <&'input str>, lambda:<LambdaAST<'input>>, position: <usize>},

        Literal => Token::StringLiteral(<&'input str>),
        I64 => Token::I64(<i64>),
        F64 => Token::F64(<f64>),
        Boolean => Token::Boolean(<bool>),

        InitPeerId => Token::InitPeerId,
        LastError => Token::LastError,
        LastErrorWithLambda => Token::LastErrorWithLambda(<LambdaAST<'input>>),
        Timestamp => Token::Timestamp,
        TTL => Token::TTL,

        call => Token::Call,
        ap => Token::Ap,
        seq => Token::Seq,
        par => Token::Par,
        fail => Token::Fail,
        fold => Token::Fold,
        xor => Token::Xor,
        new => Token::New,
        next => Token::Next,
        null => Token::Null,
        match_ => Token::Match,
        mismatch => Token::MisMatch,
    }
}
