use crate::parser::ast::*;
use crate::parser::air_parser::make_stream_iterable_error;
use crate::parser::ParserError;
use crate::parser::VariableValidator;
use crate::parser::Span;
use crate::parser::lexer::Token;

use air_lambda_parser::LambdaAST;
use lalrpop_util::ErrorRecovery;
use std::rc::Rc;

// the only thing why input matters here is just introducing lifetime for Token
grammar<'err, 'input, 'v>(input: &'input str, errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, ParserError>>, validator: &'v mut VariableValidator<'input>);

pub AIR = Instr;

Instr: Box<Instruction<'input>> = {
    <left: @L> "(" call <peer_part:PeerPart> <function_part:FPart> <args:Args> <output:Output?> ")" <right: @R> => {
        let output = output.map(CallOutputValue::Variable).unwrap_or(CallOutputValue::None);
        let args = Rc::new(args);
        let call = Call { peer_part, function_part, args, output };
        let span = Span { left, right };
        validator.met_call(&call, span);

        Box::new(Instruction::Call(call))
    },

    <left: @L> "(" ap <arg:ApArgument> <res:Output> ")" <right: @R> => {
        if let ApArgument::VariableWithLambda(vl) = &arg {
            if let AstVariable::Stream(_) = &vl.variable {
                let token = Token::VariableWithLambda(vl.variable.clone(), vl.lambda.clone());
                errors.push(make_stream_iterable_error(left, token, right));
            };
        }

        let apply = Ap::new(arg, res);
        let span = Span { left, right };
        validator.met_ap(&apply, span);

        Box::new(Instruction::Ap(apply))
    },

    "(" seq <l:Instr> <r:Instr> ")" => Box::new(Instruction::Seq(Seq(l, r))),
    "(" par <l:Instr> <r:Instr> ")" => Box::new(Instruction::Par(Par(l, r))),
    "(" null ")" => Box::new(Instruction::Null(Null)),

    <left: @L> "(" fold <iterable:ScalarIterable> <iterator:Alphanumeric> <i:Instr> ")" <right: @R> => {
        let instruction = Rc::new(*i);
        let fold = FoldScalar { iterable, iterator, instruction };
        let span = Span { left, right };
        validator.met_fold_scalar(&fold, span);

        Box::new(Instruction::FoldScalar(fold))
    },

    <left: @L> "(" fold <stream:Stream> <iterator:Alphanumeric> <i:Instr> ")" <right: @R> => {
        let instruction = Rc::new(*i);
        let fold = FoldStream { stream_name: stream, iterator, instruction };
        let span = Span { left, right };
        validator.meet_fold_stream(&fold, span);

        Box::new(Instruction::FoldStream(fold))
    },

    <left: @L> "(" next <i:Alphanumeric> ")" <right: @R> => {
        let next = Next(i);
        let span = Span { left, right };
        validator.met_next(&next, span);

        Box::new(Instruction::Next(next))
    },

    "(" xor <l:Instr> <r:Instr> ")" => Box::new(Instruction::Xor(Xor(l, r))),

    <left: @L> "(" match_ <l:Matchable> <r:Matchable> <i:Instr> ")" <right: @R> => {
        let match_ = Match { left_value: l, right_value: r, instruction: i};
        let span = Span { left, right };
        validator.met_match(&match_, span);

        Box::new(Instruction::Match(match_))
    },

    <left: @L> "(" mismatch <l:Matchable> <r:Matchable> <i:Instr> ")" <right: @R> => {
        let mismatch = MisMatch { left_value: l, right_value: r, instruction: i};
        let span = Span { left, right };
        validator.met_mismatch(&mismatch, span);

        Box::new(Instruction::MisMatch(mismatch))
     },

    ! => { errors.push(<>); Box::new(Instruction::Error) },
}

Args: Vec<CallInstrArgValue<'input>> = {
    "[" <args:(<Arg>)*> "]" => args
}

FPart: FunctionPart<'input> = {
    <f:Function> => FunctionPart::FuncName(f),
    "(" <sid:ServiceId> <f:Function> ")" => FunctionPart::ServiceIdWithFuncName(sid, f),
}

PeerPart: PeerPart<'input> = {
    <pid:PeerId> => PeerPart::PeerPk(pid),
    "(" <pid:PeerId> <sid:ServiceId> ")" => PeerPart::PeerPkWithServiceId(pid, sid),
}

Output: AstVariable<'input> = {
    <a:Alphanumeric> => AstVariable::Scalar(a),
    <s:Stream> => AstVariable::Stream(s),
};

Function = CallInstrValue;
PeerId = CallInstrValue;
ServiceId = CallInstrValue;

CallInstrValue: CallInstrValue<'input> = {
    <l:Literal> => CallInstrValue::Literal(l),
    <a:Alphanumeric> => CallInstrValue::Variable(AstVariable::Scalar(a)),
    <s:Stream> => CallInstrValue::Variable(AstVariable::Stream(s)),
    <left: @L> <vl:VariableWithLambda> <right: @R> => {
        let variable = vl.0;
        let lambda = vl.1;

        CallInstrValue::VariableWithLambda(VariableWithLambda::new(variable, lambda))
    },
    InitPeerId => CallInstrValue::InitPeerId,
}

Arg = CallInstrArgValue;

CallInstrArgValue: CallInstrArgValue<'input> = {
    <s:Literal> => CallInstrArgValue::Literal(s),
    <v:Alphanumeric> => CallInstrArgValue::Variable(AstVariable::Scalar(v)),
    <v:Stream> => CallInstrArgValue::Variable(AstVariable::Stream(v)),
    <vl:VariableWithLambda> => CallInstrArgValue::VariableWithLambda(VariableWithLambda::new(vl.0, vl.1)),
    <n:Number> => CallInstrArgValue::Number(n),
    <b:Boolean> => CallInstrArgValue::Boolean(b),
    InitPeerId => CallInstrArgValue::InitPeerId,
    EmptyArray => CallInstrArgValue::EmptyArray,
    <p:LastError> => CallInstrArgValue::LastError(p),
}

ApArgument: ApArgument<'input> = {
    <a:Alphanumeric> => ApArgument::ScalarVariable(a),
    <vl:VariableWithLambda> => ApArgument::VariableWithLambda(VariableWithLambda::new(vl.0, vl.1)),
    <n:Number> => ApArgument::Number(n),
    <b:Boolean> => ApArgument::Boolean(b),
    EmptyArray => ApArgument::EmptyArray,
    <s:Literal> => ApArgument::Literal(s),
    <p:LastError> => ApArgument::LastError(p),
};

ScalarIterable: IterableScalarValue<'input> = {
    <v:Alphanumeric> => IterableScalarValue::ScalarVariable(v),
    <l:@L> <vl:VariableWithLambda> <r:@R> => {
        use crate::parser::air::AstVariable::*;

        let variable = vl.0;
        let lambda = vl.1;

        let scalar_name = match variable {
            Stream(name) => {
                let token = Token::VariableWithLambda(variable, lambda.clone());
                errors.push(make_stream_iterable_error(l, token, r));
                name
            }
            Scalar(name) => name,
        };
        IterableScalarValue::VariableWithLambda { scalar_name, lambda }
    }
}

Matchable: MatchableValue<'input> = {
    InitPeerId => MatchableValue::InitPeerId,
    <v:Alphanumeric> => MatchableValue::Variable(AstVariable::Scalar(v)),
    <v:Stream> => MatchableValue::Variable(AstVariable::Stream(v)),
    <s:Literal> => MatchableValue::Literal(s),
    <b:Boolean> => MatchableValue::Boolean(b),
    <n:Number> => MatchableValue::Number(n),
    EmptyArray => MatchableValue::EmptyArray,
    <vl:VariableWithLambda> => MatchableValue::VariableWithLambda(VariableWithLambda::new(vl.0, vl.1)),
}

extern {
    type Location = usize;
    type Error = ParserError;

    enum Token<'input> {
        "(" => Token::OpenRoundBracket,
        ")" => Token::CloseRoundBracket,
        "[" => Token::OpenSquareBracket,
        "]" => Token::CloseSquareBracket,
        EmptyArray => Token::SquareBrackets,

        Literal => Token::StringLiteral(<&'input str>),
        Alphanumeric => Token::Alphanumeric(<&'input str>),
        Stream => Token::Stream(<&'input str>),
        VariableWithLambda => Token::VariableWithLambda(<AstVariable<'input>>, <LambdaAST<'input>>),
        Number => Token::Number(<Number>),
        Boolean => Token::Boolean(<bool>),

        InitPeerId => Token::InitPeerId,
        LastError => Token::LastError(<LastErrorPath>),

        call => Token::Call,
        ap => Token::Ap,
        seq => Token::Seq,
        par => Token::Par,
        null => Token::Null,
        fold => Token::Fold,
        xor => Token::Xor,
        next => Token::Next,
        match_ => Token::Match,
        mismatch => Token::MisMatch,
    }
}
