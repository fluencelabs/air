use crate::ast::*;
use crate::parser::ParserError;
use crate::parser::VariableValidator;
use crate::parser::Span;
use crate::parser::lexer::Token;
use crate::parser::lexer::LastErrorPath;
use crate::parser::lexer::Number;
use crate::parser::air_utils::*;
use crate::make_user_error;

use air_lambda_parser::LambdaAST;
use lalrpop_util::ErrorRecovery;
use std::rc::Rc;

// the only thing why input matters here is just introducing lifetime for Token
grammar<'err, 'input, 'v>(input: &'input str, errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, ParserError>>, validator: &'v mut VariableValidator<'input>);

pub AIR = Instr;

Instr: Box<Instruction<'input>> = {
    <left: @L> "(" call <peer_part:PeerPart> <function_part:FPart> <args:Args> <output:CallOutput?> ")" <right: @R> => {
        let triplet = match try_to_raw_triplet(peer_part, function_part) {
            Some(raw_triplet) => raw_triplet,
            None => {
                // none means error
                errors.push(make_user_error!(InvalidCallTriplet, left, Token::Call, right));
                return Box::new(Instruction::Error);
            }
        };

        let output = output.map(CallOutputValue::Variable).unwrap_or(CallOutputValue::None);
        let args = Rc::new(args);
        let call = Call { triplet, args, output};
        let span = Span { left, right };
        validator.met_call(&call, span);

        Box::new(Instruction::Call(call))
    },

    <left: @L> "(" ap <arg:ApArgument> <result:ApResult> ")" <right: @R> => {
        let apply = Ap::new(arg, result);
        let span = Span { left, right };
        validator.met_ap(&apply, span);

        Box::new(Instruction::Ap(apply))
    },

    "(" seq <l:Instr> <r:Instr> ")" => Box::new(Instruction::Seq(Seq(l, r))),
    "(" par <l:Instr> <r:Instr> ")" => Box::new(Instruction::Par(Par(l, r))),
    "(" null ")" => Box::new(Instruction::Null(Null)),

    <left: @L> "(" new <variable: ScriptVariable> <instruction:Instr> ")" <right: @R> => {
        let new = New { variable, instruction, position: left };
        let span = Span { left, right };
        validator.met_new(&new, span);
        Box::new(Instruction::New(new))
    },

    <left: @L> "(" fold <iterable:FoldScalarIterable> <iterator_name:Scalar> <i:Instr> ")" <right: @R> => {
        let iterator = Scalar { name: iterator_name };
        let instruction = Rc::new(*i);
        let fold = FoldScalar { iterable, iterator, instruction };
        let span = Span { left, right };
        validator.met_fold_scalar(&fold, span);

        Box::new(Instruction::FoldScalar(fold))
    },

    <left: @L> "(" fold <stream_name:Stream> <iterator_name:Scalar> <i:Instr> ")" <right: @R> => {
        let iterable = Stream { name: stream_name };
        let iterator = Scalar { name: iterator_name };
        let instruction = Rc::new(*i);
        let fold = FoldStream { iterable, iterator, instruction };

        let span = Span { left, right };
        validator.meet_fold_stream(&fold, span);

        Box::new(Instruction::FoldStream(fold))
    },

    <left: @L> "(" next <iterator_name:Scalar> ")" <right: @R> => {
        let iterator = Scalar { name: iterator_name };
        let next = Next { iterator };
        let span = Span { left, right };
        validator.met_next(&next, span);

        Box::new(Instruction::Next(next))
    },

    "(" xor <l:Instr> <r:Instr> ")" => Box::new(Instruction::Xor(Xor(l, r))),

    <left: @L> "(" match_ <l:Value> <r:Value> <i:Instr> ")" <right: @R> => {
        let match_ = Match { left_value: l, right_value: r, instruction: i};
        let span = Span { left, right };
        validator.met_match(&match_, span);

        Box::new(Instruction::Match(match_))
    },

    <left: @L> "(" mismatch <l:Value> <r:Value> <i:Instr> ")" <right: @R> => {
        let mismatch = MisMatch { left_value: l, right_value: r, instruction: i};
        let span = Span { left, right };
        validator.met_mismatch(&mismatch, span);

        Box::new(Instruction::MisMatch(mismatch))
     },

    ! => { errors.push(<>); Box::new(Instruction::Error) },
}

Args: Vec<Value<'input>> = {
    "[" <args:(<Arg>)*> "]" => args
}

FPart: FunctionPart<'input> = {
    <f:Function> => FunctionPart::FuncName(f),
    "(" <sid:ServiceId> <f:Function> ")" => FunctionPart::ServiceIdWithFuncName(sid, f),
}

PeerPart: PeerPart<'input> = {
    <pid:PeerId> => PeerPart::PeerPk(pid),
    "(" <pid:PeerId> <sid:ServiceId> ")" => PeerPart::PeerPkWithServiceId(pid, sid),
}

ApResult = ScriptVariable;
CallOutput = ScriptVariable;

ScriptVariable: Variable<'input> = {
    <scalar:Scalar> => Variable::scalar(scalar),
    <stream:Stream> => Variable::stream(stream),
};

FoldScalarIterable: ScalarWithLambda<'input> = {
    <scalar:Scalar> => ScalarWithLambda::new(scalar, None),
    <scalar:ScalarWithLambda> => ScalarWithLambda::new(scalar.0, Some(scalar.1)),
};

Function = CallInstrValue;
PeerId = CallInstrValue;
ServiceId = CallInstrValue;

CallInstrValue: CallInstrValue<'input> = {
    InitPeerId => CallInstrValue::InitPeerId,
    <l:Literal> => CallInstrValue::Literal(l),
    <scalar:Scalar> => CallInstrValue::Variable(VariableWithLambda::scalar(scalar)),
    <scalar:ScalarWithLambda> => CallInstrValue::Variable(VariableWithLambda::scalar_wl(scalar.0, scalar.1)),
    <stream:Stream> => CallInstrValue::Variable(VariableWithLambda::stream(stream)),
    <stream:StreamWithLambda> => CallInstrValue::Variable(VariableWithLambda::stream_wl(stream.0, stream.1)),
}

Arg = Value;

Value: Value<'input> = {
    InitPeerId => Value::InitPeerId,
    <e:LastError> => Value::LastError(e),
    <l:Literal> => Value::Literal(l),
    <n:Number> => Value::Number(n),
    <b:Boolean> => Value::Boolean(b),
    EmptyArray => Value::EmptyArray,
    <scalar_name:Scalar> => Value::Variable(VariableWithLambda::scalar(scalar_name)),
    <scalar:ScalarWithLambda> => Value::Variable(VariableWithLambda::scalar_wl(scalar.0, scalar.1)),
    <stream_name:Stream> => Value::Variable(VariableWithLambda::stream(stream_name)),
    <stream:StreamWithLambda> => Value::Variable(VariableWithLambda::stream_wl(stream.0, stream.1)),
}

ApArgument: ApArgument<'input> = {
    InitPeerId => ApArgument::InitPeerId,
    <e:LastError> => ApArgument::LastError(e),
    <l:Literal> => ApArgument::Literal(l),
    <n:Number> => ApArgument::Number(n),
    <b:Boolean> => ApArgument::Boolean(b),
    EmptyArray => ApArgument::EmptyArray,
    <scalar:Scalar> => ApArgument::Scalar(ScalarWithLambda { name: scalar, lambda: None }),
    <scalar:ScalarWithLambda> => ApArgument::Scalar(ScalarWithLambda { name: scalar.0, lambda: Some(scalar.1) }),
}

extern {
    type Location = usize;
    type Error = ParserError;

    enum Token<'input> {
        "(" => Token::OpenRoundBracket,
        ")" => Token::CloseRoundBracket,
        "[" => Token::OpenSquareBracket,
        "]" => Token::CloseSquareBracket,
        EmptyArray => Token::SquareBrackets,

        Literal => Token::StringLiteral(<&'input str>),
        Scalar => Token::Scalar { name:<&'input str> },
        ScalarWithLambda => Token::ScalarWithLambda { name: <&'input str>, lambda: <LambdaAST<'input>>},
        Stream => Token::Stream { name: <&'input str> },
        StreamWithLambda => Token::StreamWithLambda {name: <&'input str>, lambda:<LambdaAST<'input>>},
        Number => Token::Number(<Number>),
        Boolean => Token::Boolean(<bool>),

        InitPeerId => Token::InitPeerId,
        LastError => Token::LastError(<LastErrorPath>),

        call => Token::Call,
        ap => Token::Ap,
        seq => Token::Seq,
        par => Token::Par,
        fold => Token::Fold,
        xor => Token::Xor,
        new => Token::New,
        next => Token::Next,
        null => Token::Null,
        match_ => Token::Match,
        mismatch => Token::MisMatch,
    }
}
