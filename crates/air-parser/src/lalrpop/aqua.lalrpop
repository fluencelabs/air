use crate::ast::*;
use crate::lalrpop::parser::InstructionError;

use lalrpop_util::ErrorRecovery;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, InstructionError>>);

extern {
    type Error = InstructionError;
}

pub Instr: Box<Instruction<'input>> = {
    "(" <s:Seq> <l:Instr> <r:Instr> ")" => Box::new(Instruction::Seq(Seq(l, r))),
    "(" <c:Call> <peer:PeerPart> <f:FPart> <args:Args> <output:Output> ")" => Box::new(Instruction::Call(Call{peer, f, args, output})),
    ! => { errors.push(<>); Box::new(Instruction::Error) },
}

Seq: &'input str = {
    "seq"
}

Call: &'input str = {
    "call"
}

Args: Vec<Value<'input>> = {
    "(" <args:(<Arg>)*> ")" => args
}


FPart: FunctionPart<'input> = {
    <f:Function> => FunctionPart::FuncName(f),
    "(" <sid:ServiceId> <f:Function> ")" => FunctionPart::ServiceIdWithFuncName(sid, f),
}


PeerPart: PeerPart<'input> = {
    <pid:PeerId> => PeerPart::PeerPk(pid),
    "(" <pid:PeerId> <sid:ServiceId> ")" => PeerPart::PeerPkWithServiceId(pid, sid),
}

Output: CallOutput<'input> = {
    <o:Alphanumeric> => CallOutput::Scalar(o),
    <o:ACCUMULATOR> => CallOutput::Accumulator(&o[..o.len()-2]),
};

Function = Value;
PeerId = Value;
ServiceId = Value;
Arg = Value;

Value: Value<'input> = {
    "\"" <v: Alphanumeric> "\"" => Value::Literal(v),
    <v:Alphanumeric> => Value::Variable(v),
    <v:JSON_PATH> => {
        let mut path = v.splitn(2, ".");
        let variable = path.next().expect("must contain dot");
        let path = path.next().expect("contain component after dot");
        Value::JsonPath{variable, path}
    },
}



Alphanumeric = ALPHANUMERIC;

match {
    r"[0-9a-zA-Z]+" => ALPHANUMERIC,
    r"[0-9a-zA-Z]+\[\]" => ACCUMULATOR,
    r"[0-9a-zA-Z]+\.\$\.[0-9a-zA-Z]+" => JSON_PATH,
    "seq",
    "call",
} else {
    _
}

