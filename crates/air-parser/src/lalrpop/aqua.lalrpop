use crate::ast::*;
use crate::lalrpop::parser::InstructionError;

use lalrpop_util::ErrorRecovery;
use std::rc::Rc;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, InstructionError>>);

extern {
    type Error = InstructionError;
}

pub Instr: Box<Instruction<'input>> = {
    "(" "seq" <l:Instr> <r:Instr> ")" => Box::new(Instruction::Seq(Seq(l, r))),
    "(" "par" <l:Instr> <r:Instr> ")" => Box::new(Instruction::Par(Par(l, r))),
    "(" "xor" <l:Instr> <r:Instr> ")" => Box::new(Instruction::Xor(Xor(l, r))),

    "(" "call" <p:PeerPart> <f:FPart> <args:Args> <output:Output?> ")" => {
        let output = output.unwrap_or(CallOutput::None);
        let args = Rc::new(args);
        Box::new(Instruction::Call(Call{peer_part: p, function_part: f, args, output}))
    },

    "(" "fold" <iterable:InstructionValue> <iterator:Alphanumeric> <i:Instr> ")" => {
        let instruction = Rc::new(*i);
        Box::new(Instruction::Fold(Fold{ iterable, iterator, instruction }))
    },

    "(" "next" <i:Alphanumeric> ")" => Box::new(Instruction::Next(Next(i))),
    "(" "null" ")" => Box::new(Instruction::Null(Null)),
    ! => { errors.push(<>); Box::new(Instruction::Error) },
}

Args: Vec<InstructionValue<'input>> = {
    "[" <args:(<Arg>)*> "]" => args
}

FPart: FunctionPart<'input> = {
    <f:Function> => FunctionPart::FuncName(f),
    "(" <sid:ServiceId> <f:Function> ")" => FunctionPart::ServiceIdWithFuncName(sid, f),
}

PeerPart: PeerPart<'input> = {
    <pid:PeerId> => PeerPart::PeerPk(pid),
    "(" <pid:PeerId> <sid:ServiceId> ")" => PeerPart::PeerPkWithServiceId(pid, sid),
}

Output: CallOutput<'input> = {
    <o:Alphanumeric> => CallOutput::Scalar(o),
    <o:ACCUMULATOR> => CallOutput::Accumulator(&o[..o.len()-2]),
};

Function = InstructionValue;
PeerId = InstructionValue;
ServiceId = InstructionValue;
Arg = InstructionValue;

InstructionValue: InstructionValue<'input> = {
    "\"" "\"" => InstructionValue::Literal(""), // TODO: signal absence somehow?
    "\"" <v: Alphanumeric> "\"" => InstructionValue::Literal(v),
    <v:Alphanumeric> => InstructionValue::Variable(v),
    <v:JSON_PATH> => {
        let mut path = v.splitn(2, ".");
        let variable = path.next().expect("must contain dot");
        let path = path.next().expect("contain component after dot");
        InstructionValue::JsonPath { variable, path }
    },
    CURRENT_PEER_ID => InstructionValue::CurrentPeerId,
    INIT_PEER_ID => InstructionValue::InitPeerId,
}

Alphanumeric = ALPHANUMERIC;

match {
    r"[\w_-]+" => ALPHANUMERIC,
    r"[\w_-]+\[\]" => ACCUMULATOR,
    r#"[\w_-]+\.*\$([\w._-]*(\[[\w"]+\])*!*)+"# => JSON_PATH,
    r#"%current_peer_id%"# => CURRENT_PEER_ID,
    r#"%init_peer_id%"# => INIT_PEER_ID,
    "seq",
    "call",
    "null",
    "par",
    "xor",
    "fold",
    "next",
    // ignore patterns
    // see: https://lalrpop.github.io/lalrpop/lexer_tutorial/001_lexer_gen.html#customizing-skipping-between-tokens
    r"\s*" => { }, // The default whitespace skipping is disabled if an `ignore pattern` is specified
    r";[^\n\r]*[\n\r]*" => { }, // Skip `; comments`
} else {
    _
}

