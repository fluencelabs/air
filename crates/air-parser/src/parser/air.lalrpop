use crate::parser::ast::*;
use crate::parser::air_parser::into_variable_and_path;
use crate::parser::air_parser::make_flattened_error;
use crate::parser::lexer::LexerError;
use crate::parser::lexer::Token;
use crate::parser::lexer::Number;

use lalrpop_util::ErrorRecovery;
use std::rc::Rc;

// the only thing why input matters here is just introducing lifetime for Token
grammar<'err, 'input>(input: &'input str, errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, LexerError>>);

pub AIR = Instr;

Instr: Box<Instruction<'input>> = {
    "(" call <p:PeerPart> <f:FPart> <args:Args> <output:Output?> ")" => {
        let output = output.unwrap_or(CallOutputValue::None);
        let args = Rc::new(args);
        Box::new(Instruction::Call(Call{peer_part: p, function_part: f, args, output}))
    },

    "(" seq <l:Instr> <r:Instr> ")" => Box::new(Instruction::Seq(Seq(l, r))),
    "(" par <l:Instr> <r:Instr> ")" => Box::new(Instruction::Par(Par(l, r))),
    "(" null ")" => Box::new(Instruction::Null(Null)),

    "(" fold <iterable:Iterable> <iterator:Alphanumeric> <i:Instr> ")" => {
        let instruction = Rc::new(*i);
        Box::new(Instruction::Fold(Fold{ iterable, iterator, instruction }))
    },
    "(" next <i:Alphanumeric> ")" => Box::new(Instruction::Next(Next(i))),


    "(" xor <l:Instr> <r:Instr> ")" => Box::new(Instruction::Xor(Xor(l, r))),

    "(" match_ <l:Matchable> <r:Matchable> <i:Instr> ")" => {
        let match_ = Match { left_value: l, right_value: r, instruction: i};
        Box::new(Instruction::Match(match_))
    },

    "(" mismatch <l:Matchable> <r:Matchable> <i:Instr> ")" => {
        let mismatch = MisMatch { left_value: l, right_value: r, instruction: i};
        Box::new(Instruction::MisMatch(mismatch))
     },

    ! => { errors.push(<>); Box::new(Instruction::Error) },
}

Args: Vec<CallInstrArgValue<'input>> = {
    "[" <args:(<Arg>)*> "]" => args
}

FPart: FunctionPart<'input> = {
    <f:Function> => FunctionPart::FuncName(f),
    "(" <sid:ServiceId> <f:Function> ")" => FunctionPart::ServiceIdWithFuncName(sid, f),
}

PeerPart: PeerPart<'input> = {
    <pid:PeerId> => PeerPart::PeerPk(pid),
    "(" <pid:PeerId> <sid:ServiceId> ")" => PeerPart::PeerPkWithServiceId(pid, sid),
}

Output: CallOutputValue<'input> = {
    <s:Alphanumeric> => CallOutputValue::Scalar(s),
    <a:Accumulator> => CallOutputValue::Accumulator(a),
};

Function = CallInstrValue;
PeerId = CallInstrValue;
ServiceId = CallInstrValue;

CallInstrValue: CallInstrValue<'input> = {
    <s:Literal> => CallInstrValue::Literal(s),
    <s:Alphanumeric> => CallInstrValue::Variable(s),
    <l: @L> <v:JsonPath> <r: @R> => {
        let (variable, path) = into_variable_and_path(v.0, v.1, v.2);
        let should_flatten = v.2;
        if !should_flatten {
            let token = Token::JsonPath(v.0, v.1, v.2);
            errors.push(make_flattened_error(l, token, r));
        }
        CallInstrValue::JsonPath { variable, path, should_flatten }
    },
    InitPeerId => CallInstrValue::InitPeerId,
}

Arg = CallInstrArgValue;

CallInstrArgValue: CallInstrArgValue<'input> = {
    <s:Literal> => CallInstrArgValue::Literal(s),
    <s:Alphanumeric> => CallInstrArgValue::Variable(s),
    <v:JsonPath> => {
        let (variable, path) = into_variable_and_path(v.0, v.1, v.2);
        let should_flatten = v.2;
        CallInstrArgValue::JsonPath { variable, path, should_flatten }
    },
    <n:Number> => CallInstrArgValue::Number(n),
    <b:Boolean> => CallInstrArgValue::Boolean(b),
    InitPeerId => CallInstrArgValue::InitPeerId,
    LastError => CallInstrArgValue::LastError,
}

Iterable: IterableValue<'input> = {
    <s:Alphanumeric> => IterableValue::Variable(s),
    <v:JsonPath> => {
        let (variable, path) = into_variable_and_path(v.0, v.1, v.2);
        let should_flatten = v.2;
        IterableValue::JsonPath { variable, path, should_flatten }
    },
}

Matchable: MatchableValue<'input> = {
    <s:Alphanumeric> => MatchableValue::Variable(s),
    <s:Literal> => MatchableValue::Literal(s),
    <v:JsonPath> => {
        let (variable, path) = into_variable_and_path(v.0, v.1, v.2);
        let should_flatten = v.2;
        MatchableValue::JsonPath { variable, path, should_flatten }
    },
}

extern {
    type Location = usize;
    type Error = LexerError;

    enum Token<'input> {
        "(" => Token::OpenRoundBracket,
        ")" => Token::CloseRoundBracket,
        "[" => Token::OpenSquareBracket,
        "]" => Token::CloseSquareBracket,

        Alphanumeric => Token::Alphanumeric(<&'input str>),
        Literal => Token::StringLiteral(<&'input str>),
        JsonPath => Token::JsonPath(<&'input str>, <usize>, <bool>),
        Accumulator => Token::Accumulator(<&'input str>),
        Number => Token::Number(<Number>),
        Boolean => Token::Boolean(<bool>),

        InitPeerId => Token::InitPeerId,
        LastError => Token::LastError,

        call => Token::Call,
        seq => Token::Seq,
        par => Token::Par,
        null => Token::Null,
        fold => Token::Fold,
        xor => Token::Xor,
        next => Token::Next,
        match_ => Token::Match,
        mismatch => Token::MisMatch,
    }
}
