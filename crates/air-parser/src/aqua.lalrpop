use crate::ast::*;
use crate::lalrpop::InstructionError;

use lalrpop_util::ErrorRecovery;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, InstructionError>>);

extern {
    type Error = InstructionError;
}

pub Instr: Box<Instruction<'input>> = {
    "(" <s:Seq> <l:Instr> <r:Instr> ")" => Box::new(Instruction::Seq(Seq(l, r))),
    "(" <c:Call> <peer:PeerPart> <f:FPart> <args:Args> <output:Output> ")" => Box::new(Instruction::Call(Call{peer, f, args, output})),
    ! => { errors.push(<>); Box::new(Instruction::Error) },
}

Seq: &'input str = {
    "seq"
}

Call: &'input str = {
    "call"
}

Args: Vec<&'input str> = {
    "(" <args:(<Arg>)*> ")" => args
}


FPart: FunctionPart<'input> = {
    <f:Function> => FunctionPart::FuncName(f),
    "(" <sid:ServiceId> <f:Function> ")" => FunctionPart::ServiceIdWithFuncName(sid, f),
}


PeerPart: PeerPart<'input> = {
    <pid:PeerId> => PeerPart::PeerPk(pid),
    "(" <pid:PeerId> <sid:ServiceId> ")" => PeerPart::PeerPkWithServiceId(pid, sid),
}

Output: CallOutput<'input> = {
    <o:Alphanumeric> => CallOutput::Scalar(o),
    <o:ACCUMULATOR> => CallOutput::Accumulator(o),
};

Function = Alphanumeric;
PeerId = Alphanumeric;
ServiceId = Alphanumeric;
Arg = Alphanumeric;
LBR = "(";
RBR = ")";

Alphanumeric: &'input str = {
    ALPHANUMERIC
}

match {
    r"[0-9a-zA-Z]+" => ALPHANUMERIC,
    "seq",
    "call",
} else {
    r"[0-9a-zA-Z]+\[\]" => ACCUMULATOR,
    _
}

